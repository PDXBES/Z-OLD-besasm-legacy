{*******************************************************}
{*
{* uTFlowSeriesList.pas
{* Delphi Implementation of the Class TFlowSeriesList
{* Generated by Enterprise Architect
{* Created on:      03-May-2006 11:45:48 AM
{* Original author: Arnel Mandilag
{*
{*******************************************************}

unit uTFlowSeriesList;

interface

uses SysUtils, Classes, Contnrs, Math, DateUtils, Types,
	uTFlowSeriesDatum;

type

	//A first-in, first-out (queue) list of flows that holds enough records to
	//provide lagging of hydrographs
	//To correctly distribute flow, we have to lag the flow "ahead" since we're
	//distributing flows upstream
	TFlowSeriesList = class
	private
		List: TObjectList;
		MaxLagTime: Double;
	protected
		function GetItem(Index: Integer): TFlowSeriesDatum;
	public
		MasterTime: TDateTime;
		procedure Add(ADatum: TFlowSeriesDatum);
		procedure StripOldData(ATime: TDateTime);
		procedure Clear;
		procedure Delete;
		constructor Create(AStartTime: TDateTime; LagTime: Integer); overload;
		destructor Destroy; override;
		function Count: Integer;
		function FlowAtTime(ATime: TDateTime): Double;
		procedure SetMaxLagTime(ATime: Double);
		property Items[Index : Integer]:TFlowSeriesDatum read GetItem; default;
	end;

implementation

uses CodeSiteLogging;

{implementation of TFlowSeriesList}

procedure TFlowSeriesList.Add(ADatum: TFlowSeriesDatum);
var
	TimeDiff: Double;
begin
	StripOldData(MasterTime);
	List.Add(ADatum);
end;

procedure TFlowSeriesList.StripOldData(ATime: TDateTime);
begin
	if List.Count = 0 then
		Exit;
	while (List.Count > 1) and
		(CompareDateTime(ATime, TFlowSeriesDatum(List[1]).Time) > EqualsValue) do
	begin
		Delete;
	end;
end;

procedure TFlowSeriesList.Clear;
begin
	List.Clear;
end;

function TFlowSeriesList.Count: Integer;
begin
	Result := List.Count;
end;

procedure TFlowSeriesList.Delete;
begin
	List.Delete(0);
end;

function TFlowSeriesList.GetItem(Index: Integer): TFlowSeriesDatum;
begin
	Result := TFlowSeriesDatum(List[Index]);
end;

procedure TFlowSeriesList.SetMaxLagTime(ATime: Double);
begin
	MaxLagTime := ATime;
end;

constructor TFlowSeriesList.Create(AStartTime: TDateTime; LagTime: Integer);
var
	AFlowSeriesDatum: TFlowSeriesDatum;
	LaggedAheadTime: TDateTime;
begin
	List := TObjectList.Create(True);

{	LaggedAheadTime := IncMinute(AStartTime, -LagTime);
	AFlowSeriesDatum := TFlowSeriesDatum.Create;
	AFlowSeriesDatum.Flow := 0;
	AFlowSeriesDatum.Time := LaggedAheadTime;
	List.Add(AFlowSeriesDatum);}

	MaxLagTime := LagTime;
end;

destructor TFlowSeriesList.Destroy;
begin
	List.Free;
	inherited;
end;

function TFlowSeriesList.FlowAtTime(ATime: TDateTime): Double;
var
	i: Integer;
	LateTime: TDateTime;
	LateFlow: Double;
	EarlyTime: TDateTime;
	EarlyFlow: Double;
	ATimeSpan: Double;
	LateEarlySpan: Double;
	LateIndex: Integer;

	AFlowDatum: TFlowSeriesDatum;
	CheckStrings: TStringList;
begin
	// Search for the two data that surround ATime
	LateIndex := -1;
	for i := 0 to List.Count - 1 do
		if CompareDateTime(TFlowSeriesDatum(List[i]).Time, ATime) > EqualsValue then
		begin
			// if oldest date is greater than ATime, then return a zero
			if i = 0 then
			begin
				Result := 0;
				Exit;
			end
			else
			begin
				LateIndex := i;
				Break;
			end;
		end;

  // If we're on the last data point, use that data point
	if LateIndex = -1 then
	begin
		if CompareDateTime(TFlowSeriesDatum(List[List.Count-1]).Time, ATime) = EqualsValue then
		begin
			Result := TFlowSeriesDatum(List[List.Count-1]).Flow;
			Exit;
		end
    // otherwise, use zero
		else
		begin
//			Assert(False, 'FlowAtTime: Requested Date = ' + DateTimeToStr(ATime) +
//				' is later than most recent Flow History Date = ' +
//				DateTimeToStr(TFlowSeriesDatum(List[List.Count-1]).Time));
      Result := 0;
			Exit;
		end;
	end;

{
  	CheckStrings := TStringList.Create;
  	CheckStrings.Add('LateIndex='+IntToStr(LateIndex));
  	for i := 0 to List.Count - 1 do
  	begin
  		AFlowDatum := TFlowSeriesDatum(List[i]);
  		CheckStrings.Add(Format('%s = %.5f', [FormatDateTime('m/d/y hh:mm', AFlowDatum.Time),
  			AFlowDatum.Flow]));
  	end;

	CodeSite.Send('FlowAtTime '+FormatDateTime('m/d/y hh:mm', ATime), CheckStrings);
	CheckStrings.Free;
}

	// Interpolate flow
	EarlyTime := TFlowSeriesDatum(List[LateIndex-1]).Time;
	EarlyFlow := TFlowSeriesDatum(List[LateIndex-1]).Flow;
	LateTime := TFlowSeriesDatum(List[LateIndex]).Time;
	LateFlow := TFlowSeriesDatum(List[LateIndex]).Flow;

	ATimeSpan := MinuteSpan(ATime, EarlyTime);
	LateEarlySpan := MinuteSpan(LateTime, EarlyTime);

	Result := EarlyFlow + ATimeSpan*(LateFlow - EarlyFlow)/(LateEarlySpan);
end;

end.