{*******************************************************}
{*
{* uTDistributionCombiner.pas
{* Delphi Implementation of the Class TDistributionCombiner
{* Generated by Enterprise Architect
{* Created on:      03-May-2006 11:45:48 AM
{* Original author: Arnel Mandilag
{*
{*******************************************************}

unit uTDistributionCombiner;

interface

uses SysUtils, Classes, Contnrs, DateUtils, Types, Math,
	uTLink, uTLinksList, uTNetwork, uTNode, uTDistribution, uTAggregatedNode,
	uTFlowFileSpecs, uTMainConfigSpecs;

type

	//Combines all the distributions specified in a configuration and writes out the
	//interface file
	TDistributionCombiner = class
	private
		Distributions: TObjectList;
		Nodes: TStringList;
    function GetNumDistributions: Integer;
	protected
		function DistributionAvailable: Boolean;
	public
		CurrentTime: TDateTime;
		StartTime: TDateTime;
		EndTime: TDateTime;
		TimeStep: Double;
		OutputPath: TFilename;
		function LongestLagTime: Double;
		function EarliestDistributionTime: TDateTime;
		//Creates a distribution using information from the configuration
		function AddDistribution(ANetwork: TNetwork; ARoot: TLink; Stops: TLinksList;
			FlowFile: TFileName; FlowFileSpecs: TFlowFileSpecs; AModelPath: String;
			MainConfigSpecs: TMainConfigSpecs; VelocityFactor: Double): integer;
    //Clears the distribution list;
    procedure Clear;
		//Adds a distribution/node combination (to be held in TAggregatedNode) for use in
		//assembling flows
    property NumDistributions: Integer read GetNumDistributions;
		procedure AddNode(ADistribution: TDistribution; ANode: TNode);
		//Writes out the entire output interface file with all the distributions and
		//corresponding lags applied
		procedure SetDistributionMasterTimes;
		procedure WriteInterface;
		constructor Create; overload;
		destructor Destroy; override;
	end;

implementation

uses StStrms, PDXDateUtils, CodeSiteLogging, uIM_InterfaceFiles,
	uIM_SWMM_XP_InterfaceFiles, fStatus, fProgress, Forms;

{implementation of TDistributionCombiner}

function TDistributionCombiner.AddDistribution(ANetwork: TNetwork; ARoot: TLink; Stops: TLinksList;
	FlowFile: TFileName; FlowFileSpecs: TFlowFileSpecs; AModelPath: String;
	MainConfigSpecs: TMainConfigSpecs; VelocityFactor: Double): Integer;
var
	ADistribution: TDistribution;
	i: Integer;
begin
  try
    ADistribution := TDistribution.Create(ANetwork, ARoot, Stops, FlowFile,
      FlowFileSpecs, AModelPath, MainConfigSpecs, VelocityFactor);
    Distributions.Add(ADistribution);
    for i := 0 to ADistribution.NodeCount - 1 do
      AddNode(ADistribution, ADistribution.Node[i]);
  except on E: Exception do
    raise;
  end;
end;

procedure TDistributionCombiner.AddNode(ADistribution: TDistribution; ANode: TNode);
var
	NodeIndex: Integer;
begin
	if (ANode.Proportion > 0) then
	begin
		NodeIndex := Nodes.IndexOf(ANode.NodeID);
		if NodeIndex = -1 then
			NodeIndex := Nodes.AddObject(ANode.NodeID, TAggregatedNode.Create(ANode.NodeID));
		TAggregatedNode(Nodes.Objects[NodeIndex]).AddMapping(ADistribution, ANode.NodeID);
	end;
end;

procedure TDistributionCombiner.WriteInterface;
const
	ProgressUpdateCycle = 300;
var
	AFile: TFileStream;
	ATextStream: TStAnsiTextStream;
	ADistribution: TDistribution;
	i: Integer;
	NodeIndex: Integer;
	WriteString: String;

	InterfaceFile: IIM_InterfaceFile;
	InterfaceHeader: IIM_InterfaceHeader;
	InterfaceIO: IIM_InterfaceFileIO;
	ProgressUpdateCounter: Integer;
  OutputFileName: string;
begin
{	AFile := TFileStream.Create(OutputPath, fmCreate);
	ATextStream := TStAnsiTextStream.Create(AFile);}

	for i := 0 to Distributions.Count - 1 do
		TDistribution(Distributions[i]).First;

{	WriteString := 'Nodes';
	for NodeIndex := 0 to Nodes.Count - 1 do
		WriteString := WriteString + ',' + TAggregatedNode(Nodes.Objects[NodeIndex]).ID;
	ATextStream.WriteLine(WriteString);}

	InterfaceFile := T_SWMM_XP_StandardInterfaceFile.Create(OutputPath, fmCreate);
	InterfaceHeader := InterfaceFile.GetHeader;
	InterfaceHeader.HeaderValue[IM_IFHDR_TITLE1] := '';
	InterfaceHeader.HeaderValue[IM_IFHDR_TITLE2] := '';
	InterfaceHeader.HeaderValue[IM_IFHDR_TITLE3] := '';
	InterfaceHeader.HeaderValue[IM_IFHDR_TITLE4] := '';
	InterfaceHeader.HeaderValue[IM_IFHDR_SOURCE] := 'IMFlowDistrib';
	InterfaceHeader.HeaderValue[IM_IFHDR_STARTDATE] := StartTime;
	InterfaceHeader.HeaderValue[IM_IFHDR_AREA] := 0.1;
	InterfaceHeader.HeaderValue[IM_IFHDR_MULTIPLIER] := 1.0;
	for NodeIndex := 0 to Nodes.Count - 1 do
		InterfaceHeader.AddIndexedHeaderValue(TAggregatedNode(Nodes.Objects[NodeIndex]).ID);
	InterfaceHeader.WriteHeader;

	InterfaceIO := InterfaceFile.GetIOServices;

	frmProgress.prgProgress.TotalParts := 100;
	frmProgress.prgProgress.PartsComplete := 0;
	if not (CompareDateTime(EndTime, MaxDateTime) < EqualsValue) then
	begin
		frmProgress.prgProgress.Hide;
	end;
	frmProgress.Show;
	frmProgress.Update;
	ProgressUpdateCounter := 0;
	OutputFileName := ExtractFileName(OutputPath);
	while DistributionAvailable do
	begin
//		CodeSite.AddSeparator;
//		CodeSite.SendDateTime('CurrentTime', CurrentTime);
{		WriteString := Format('%s,%.2f,%.2f',
			[FormatDateTime('mm/dd/yyyy hh:mm:ss', CurrentTime),
			SecondsOfDayOfDateTime(CurrentTime),
			TimeStep]);
		for NodeIndex := 0 to Nodes.Count - 1 do
		begin
			WriteString := WriteString + Format(',%.5f',
				[TAggregatedNode(Nodes.Objects[NodeIndex]).TotalFlow]);
		end;
		ATextStream.WriteLine(WriteString);
}
		if CompareDateTime(CurrentTime, StartTime) >= EqualsValue then
		begin
			InterfaceIO.WriteInteger(Y2KJulDateOfDateTime(CurrentTime));
			InterfaceIO.WriteDouble(SecondsOfDayOfDateTime(CurrentTime));
			InterfaceIO.WriteDouble(TimeStep);
			for NodeIndex := 0 to Nodes.Count - 1 do
				InterfaceIO.WriteDouble(TAggregatedNode(Nodes.Objects[NodeIndex]).TotalFlow);
		end;

		CurrentTime := IncSecond(CurrentTime, Round(TimeStep));
		for i := 0 to Distributions.Count - 1 do
			TDistribution(Distributions[i]).UpdateFlows(CurrentTime);
		if (ProgressUpdateCounter mod ProgressUpdateCycle) = 0 then
		begin
			if CompareDateTime(CurrentTime, StartTime) >= EqualsValue then
				frmProgress.lblProgress.Caption := 'Writing '+ OutputFileName +' at ' +
					FormatDateTime('mm/dd/yyyy hh:mm', CurrentTime)
			else
				frmProgress.lblProgress.Caption := 'Scanning for start of interface file at ' +
					FormatDateTime('mm/dd/yyyy hh:mm', StartTime) + #13' Currently at ' +
					FormatDateTime('mm/dd/yyyy hh:mm', CurrentTime);
		end;
		Inc(ProgressUpdateCounter);

		if not (CompareDateTime(EndTime, MaxDateTime) = EqualsValue) and
			(CompareDateTime(CurrentTime, StartTime) >= EqualsValue) then
		begin
			frmProgress.prgProgress.PartsComplete := Round((CurrentTime - StartTime) /
				(EndTime - StartTime) * 100);
		end;
		Application.ProcessMessages;
	end;
	frmProgress.prgProgress.Show;
	frmProgress.Hide;

{	ATextStream.Free;
	AFile.Free;}
end;

procedure TDistributionCombiner.Clear;
begin
  Distributions.Clear;
end;

constructor TDistributionCombiner.Create;
begin
	Distributions := TObjectList.Create(True);
	Nodes := TStringList.Create;
	Nodes.Sorted := True;
	Nodes.Duplicates := dupError;
end;

destructor TDistributionCombiner.Destroy;
begin
	Nodes.Free;
	Distributions.Free;
	inherited;
end;

function TDistributionCombiner.DistributionAvailable: Boolean;
var
	i: Integer;
	FlowHistoryStrings: TStringList;
	j: Integer;
begin
	Result := False;

	if CompareDateTime(CurrentTime, EndTime) > EqualsValue then
  	Exit;

	for i := 0 to Distributions.Count - 1 do
	begin
//		FlowHistoryStrings := TStringList.Create;
//		for j := 0 to TDistribution(Distributions[i]).FlowHistory.Count - 1 do
//			FlowHistoryStrings.Add(
//				FormatDateTime('mm/dd/yyyy hh:mm, ',
//				TDistribution(Distributions[i]).FlowHistory[j].Time) +
//				Format('%.5f', [TDistribution(Distributions[i]).FlowHistory[j].Flow]));
//		CodeSite.Send(Format('FlowHistory %s',
//			[FormatDateTime('mm/dd/yyyy hh:mm', CurrentTime)]), FlowHistoryStrings);
//		FlowHistoryStrings.Free;

		if TDistribution(Distributions[i]).HasNext then
		begin
			Result := True;
			Exit;
		end;

	end;
end;

function TDistributionCombiner.EarliestDistributionTime: TDateTime;
var
	i: Integer;
begin
	Result := MaxDateTime;
	for i := 0 to Distributions.Count - 1 do
	begin
		if CompareDateTime(TDistribution(Distributions[i]).EarliestTime, Result) < EqualsValue then
			Result := TDistribution(Distributions[i]).EarliestTime;
	end;
end;

function TDistributionCombiner.GetNumDistributions: Integer;
begin
  Result := Distributions.Count;
end;

function TDistributionCombiner.LongestLagTime: Double;
var
  i: Integer;
begin
	Result := 0;
	for i := 0 to Distributions.Count - 1 do
		Result := Max(Result, TDistribution(Distributions[i]).LagTime);
end;

procedure TDistributionCombiner.SetDistributionMasterTimes;
var
	i: Integer;
begin
	for i := 0 to Distributions.Count - 1 do
    TDistribution(Distributions[i]).FlowHistory.MasterTime := CurrentTime;
end;

end.