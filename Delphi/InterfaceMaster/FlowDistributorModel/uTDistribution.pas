{*******************************************************}
{*
{* uTDistribution.pas
{* Delphi Implementation of the Class TDistribution
{* Generated by Enterprise Architect
{* Created on:      03-May-2006 11:45:48 AM
{* Original author: Arnel Mandilag
{*
{*******************************************************}

unit uTDistribution;

interface

uses SysUtils, Classes, Contnrs, StrUtils, Windows, Types,
	stStrms,
	uTNetwork, uTNode, uTFlowSeriesDatum, uTFlowSeriesList, uTFlowFileSpecs,
	uTLinksList, uTLink, uTNodesList, uTMainConfigSpecs;

type

  ///<summary>
  ///  Traces part of a network and applies/distributes a flow file to the nodes
  ///  in the trace
  ///</summary>
	//Traces part of a network and applies/distributes a flow file to the nodes in
	TDistribution = class
	private
		//Once the longest lag time for a distribution has been calculated, it no longer
			//needs to be calculated, and so this field holds that value.
		CachedLongestLagTime: Double;
		//Current time of the time series stream (as stated on the time series file)
		CurrentTime: TDateTime;
		//Amount of time to offset the time series
		OffsetDays: Double;
		//Marker for the root of the distribution trace
		RootMarker: TLink;
		//Start time detected on the data stream
		StartTime: TDateTime;
		//List of stop markers for the distribution network
		StopMarkers: TLinksList;
		//Name of file containing data stream
		TimeSeriesPath: TFileName;
		//Back end file stream for the flow time series
		TimeSeriesStream: TFileStream;
		//Text-formatted stream that uses TimeSeriesStream as the back end
		TimeSeriesTextStream: TStAnsiTextStream;
		Nodes: TStringList;
		NodesList: TNodesList;
		CurrentLine: String;
		EstimatedTimeStep: Double;
		FlowFileSpecs: TFlowFileSpecs;
		DistributionFormatSettings: TFormatSettings;

		//Traces the distribution and assigns the flow proportions and lag times to the
		//nodes
		procedure AssignNodeProportions(AModelPath: String; MainConfigSpecs: TMainConfigSpecs);
		function ReadFlowLine(ALine: String): TFlowSeriesDatum;
	protected
		function CachedMinutes: Double;
		function NewestFlowTime: TDateTime;
		function OldestFlowTime: TDateTime;
		function GetNode(AIndex: Integer): TNode;
	public
		FlowHistory: TFlowSeriesList;
		EarliestTime: TDateTime;
		LatestTime: TDateTime;
		//Returns the current time in the data stream (CurrentTime) offset by OffsetTime
		function AbsoluteCurrentTime: TDateTime;
		//Moves to the first record of the time series
		//
		procedure First;
		//Returns the properly lagged flow at a node at the current time step
		function FlowAt(ANode: TNode): Double;
		//Determines if there are more items to grab from the time series stream
		function HasNext: boolean;
		//Returns true if at end of file, false otherwise
		function IsEOF: boolean;
		//Reads next line in time series stream and updates FlowHistory
		procedure Next;
		//Trace takes the downstream and upstream limits of a distribution and traces the
		//network.  For the flow distributor, we assume that there is only one downstream
		//element (the point at which the flow file is describing).  Trace also assigns
		//the lengths, proportions, and time travels relative to the root point to the
		//nodes.
		function Trace(ANetwork: TNetwork; VelocityFactor: Double): boolean;
		function NodeById(ANodeID: String): TNode;
		property Node[AIndex: Integer]: TNode read GetNode;
		function NodeCount: Integer;
		procedure UpdateFlows(ATime: TDateTime);
		property LagTime: Double read CachedLongestLagTime;
		constructor Create(ANetwork: TNetwork; Root: TLink; Stops: TLinksList;
			FlowFilePath: TFileName; FlowFileSpecs: TFlowFileSpecs;
			ModelPath: String; MainConfigSpecs: TMainConfigSpecs; VelocityFactor: Double);
		destructor Destroy; override;
	end;

implementation

uses dmIM_FlowDistributionSupport, ADODB, Math, StStrL, DateUtils,
	CodeSiteLogging, fProgress, Forms, Dialogs;

{implementation of TDistribution}

function TDistribution.AbsoluteCurrentTime: TDateTime;
begin
	Result := CurrentTime + OffsetDays;
end;

procedure TDistribution.AssignNodeProportions(AModelPath: String;
	MainConfigSpecs: TMainConfigSpecs);
var
	ACommand: TADOCommand;
	DistribTable: TADOTable;
	i: Integer;
	TotalDistribution: Double;
	NodeIndex: Integer;

  function TableExists(ATableName: String): Boolean;
  begin
    try
      ACommand.CommandText := 'SELECT * FROM ' + ATableName + ' WHERE 1=0';
      ACommand.Execute;
      Result := True;
    except
      Result := False;
    end;
  end;

begin
	// Delete temporary tables if they already exist
  // Doesn't work yet...need to detect whether they exist first, then delete
  // Otherwise, go into mst_links_ac.mdb and delete IM_DistributionNodes table,
  // <DistributionField> query, and IM_LinkAreas query.
	ACommand := dmFlowDistributionSupport.adoCommand;

{
    ACommand.CommandText :=
      'DROP TABLE IM_DistributionNodes';
    ACommand.Execute;
    ACommand.CommandText :=
      'DROP VIEW '+MainConfigSpecs.DistributionTable+', IM_LinkAreas';
    ACommand.Execute;
}

	// Create utility tables and views
  if TableExists('IM_DistributionNodes') then
  begin
    ACommand.CommandText := 'DROP TABLE IM_DistributionNodes';
    ACommand.Execute;
  end;
	ACommand.CommandText :=
		'CREATE TABLE IM_DistributionNodes '+
		'(NodeID Text(20))';
	ACommand.Execute;

  if TableExists(MainConfigSpecs.DistributionTable) then
  begin
    ACommand.CommandText := 'DROP VIEW ' + MainConfigSpecs.DistributionTable;
    ACommand.Execute;
  end;
	ACommand.CommandText :=
		'CREATE VIEW '+MainConfigSpecs.DistributionTable+' AS '+
		'SELECT * '+
		'FROM '+MainConfigSpecs.DistributionTable+' IN '''+
      AModelPath+MainConfigSpecs.DistributionSource+'''';
	ACommand.Execute;

  if TableExists('IM_LinkAreas') then
  begin
    ACommand.CommandText := 'DROP VIEW IM_LinkAreas';
    ACommand.Execute;
  end;
	ACommand.CommandText :=
		'CREATE VIEW IM_LinkAreas AS '+
		'SELECT '+MainConfigSpecs.DistributionTable+'.'+MainConfigSpecs.NodeField+' AS NodeField, '+
      'Sum('+MainConfigSpecs.DistributionTable+'.'+MainConfigSpecs.DistributionField+
			') AS DistribField '+
		'FROM '+MainConfigSpecs.DistributionTable+' INNER JOIN IM_DistributionNodes ON '+
      MainConfigSpecs.DistributionTable+'.'+MainConfigSpecs.NodeField+
			' = IM_DistributionNodes.NodeID '+
		'GROUP BY '+MainConfigSpecs.DistributionTable+'.'+MainConfigSpecs.NodeField+';';
	ACommand.Execute;

{	ACommand.CommandText :=
		'CREATE VIEW mdl_Laterals_ac AS ' +
		'SELECT * ' +
		'FROM mdl_Laterals_ac IN '''+AModelPath+'\Laterals\mdl_Laterals_ac.mdb''';
	ACommand.Execute;
	ACommand.CommandText :=
		'CREATE VIEW IM_LinkAreas AS ' +
		'SELECT mdl_Links_ac.USNode, Sum(mdl_dirSC_ac.'+MainConfigSpecs.DistributionField+') AS DistribField '+
		'FROM (mdl_dirSC_ac INNER JOIN (mdl_Laterals_ac INNER JOIN mdl_Links_ac '+
		'ON mdl_Laterals_ac.LinkID = mdl_Links_ac.LinkID) ON '+
		'mdl_dirSC_ac.LateralIDSan = mdl_Laterals_ac.LateralID) INNER JOIN '+
		'IM_DistributionNodes ON mdl_Links_ac.USNode = IM_DistributionNodes.NodeID '+
		'GROUP BY mdl_Links_ac.USNode';
	ACommand.Execute;}

	// Fill in the nodes table
	frmProgress.prgProgress.TotalParts := Nodes.Count;
	frmProgress.prgProgress.PartsComplete := 0;
	frmProgress.lblProgress.Caption := 'Filling in nodes from trace for proportion analysis';
	frmProgress.Show;
	dmFlowDistributionSupport.adoDistributionNodes.Open;
	for i := 0 to Nodes.Count - 1 do
	begin
		dmFlowDistributionSupport.adoDistributionNodes.AppendRecord([Nodes[i]]);
		frmProgress.prgProgress.IncPartsByOne;
		Application.ProcessMessages;
	end;
	dmFlowDistributionSupport.adoDistributionNodes.Close;
	frmProgress.Hide;

	// Execute query between dsc and temporary nodes table to get proportions
	dmFlowDistributionSupport.adoProportion.SQL.Clear;
	dmFlowDistributionSupport.adoProportion.SQL.Add(
		'SELECT Sum(IM_LinkAreas.DistribField) AS SumOfDistribField ' +
		'FROM IM_LinkAreas;');
	dmFlowDistributionSupport.adoProportion.Open;
  if dmFlowDistributionSupport.adoProportion.RecordCount = 0 then
  begin
//    ShowMessage(Format('No records in the distribution table match any nodes in the distribution ' +
//      'trace for distribution of the flow file %s', [Self.TimeSeriesPath]));
    raise Exception.Create('Distribution table doesn''t match any node in trace');
  end;
  
	dmFlowDistributionSupport.adoProportion.First;
	TotalDistribution :=
		dmFlowDistributionSupport.adoProportion.FieldValues['SumOfDistribField'];
	dmFlowDistributionSupport.adoProportion.Close;

	// Assign proportions
	dmFlowDistributionSupport.adoLinkAreas.Open;
	dmFlowDistributionSupport.adoLinkAreas.First;
	while not dmFlowDistributionSupport.adoLinkAreas.EOF do
	begin
		NodeIndex := Nodes.IndexOf(dmFlowDistributionSupport.adoLinkAreas.FieldValues['NodeField']);
		NodesList[NodeIndex].SetProportion(dmFlowDistributionSupport.adoLinkAreas.FieldValues['DistribField'] /
			TotalDistribution);
//		CodeSite.Send('Proportion '+Nodes[NodeIndex], NodesList[NodeIndex].Proportion);
		dmFlowDistributionSupport.adoLinkAreas.Next;
	end;
	dmFlowDistributionSupport.adoLinkAreas.Close;

	// Delete temporary table
	ACommand.CommandText :=
		'DROP TABLE IM_DistributionNodes';
	ACommand.Execute;
	ACommand.CommandText := 'DROP VIEW '+
		MainConfigSpecs.DistributionTable+', IM_LinkAreas';
	ACommand.Execute;
end;

function TDistribution.CachedMinutes: Double;
begin
	Result := CachedLongestLagTime;
end;

procedure TDistribution.First;
var
	i: Integer;
begin
	TimeSeriesTextStream.SeekLine(0);
	for i := 0 to FlowFileSpecs.HeaderLines - 1 do
		TimeSeriesTextStream.ReadLine;
	Next;
	CurrentTime := FlowHistory[0].Time;
end;

function TDistribution.FlowAt(ANode: TNode): Double;
begin
	Result := ANode.DistributeFlow(FlowHistory.MasterTime, FlowHistory, CachedLongestLagTime) *
		FlowFileSpecs.Multiplier;
//	CodeSite.Send(ANode.NodeID, Result);
end;

function TDistribution.GetNode(AIndex: Integer): TNode;
begin
	Result := NodesList[AIndex];
end;

function TDistribution.HasNext: boolean;
begin
	Result := (not TimeSeriesTextStream.AtEndOfStream) and
		(FlowHistory.Count > 0);
end;

function TDistribution.IsEOF: boolean;
begin
	Result := TimeSeriesTextStream.AtEndOfStream;
end;

function TDistribution.NewestFlowTime: TDateTime;
begin
	Result := FlowHistory[FlowHistory.Count-1].Time;
end;

procedure TDistribution.Next;
var
	ADatum: TFlowSeriesDatum;
begin
	if not TimeSeriesTextStream.AtEndOfStream then
	begin
		CurrentLine := TimeSeriesTextStream.ReadLine;
		ADatum := ReadFlowLine(CurrentLine);
		FlowHistory.Add(ADatum);
		CurrentTime := ADatum.Time;
		CurrentTime := IncMinute(CurrentTime, -Round(CachedLongestLagTime));
	end
	else
	begin
		CurrentTime := IncMinute(CurrentTime, Round(EstimatedTimeStep));
		FlowHistory.StripOldData(CurrentTime);
	end;

end;

function TDistribution.NodeById(ANodeID: String): TNode;
var
	NodeIndex: Integer;
begin
	NodeIndex := Nodes.IndexOf(ANodeID);
	Result := NodesList[NodeIndex];
end;

function TDistribution.NodeCount: Integer;
begin
	Result := NodesList.Count;
end;

function TDistribution.OldestFlowTime: TDateTime;
begin
	Result := FlowHistory[0].Time;
end;

function TDistribution.ReadFlowLine(ALine: String): TFlowSeriesDatum;
var
	Tokens: TStringList;
begin
	Tokens := TStringList.Create;
	ExtractTokensL(ALine, FlowFileSpecs.Delimiter, '''', False, Tokens);
	Result := TFlowSeriesDatum.Create;
	Result.Time := StrToDate(Tokens[0], DistributionFormatSettings) +
		StrToTime(Tokens[1], DistributionFormatSettings);
	Result.Flow := StrToFloat(Tokens[2]);
	Tokens.Free
end;

function TDistribution.Trace(ANetwork: TNetwork; VelocityFactor: Double): boolean;
var
	TraceStack: TStack;
	TracedLinks: TObjectList;
	ALinkID: Integer;
	ALink: TLink;
	UpstreamLinks: TLinksList;
	i: Integer;
	ANode: TNode;
	VisitedNodes: TStringList;
	AddedIndex: Integer;
	CheckStrings: TStringList;

	function IsEnd(ALink: TLink): boolean;
	var
		j: Integer;
	begin
		Result := False;
		for j := 0 to StopMarkers.Count - 1 do
			if StopMarkers[j].LinkID = ALink.LinkID then
			begin
				Result := True;
				Break;
			end;
	end;

begin
	TraceStack := TStack.Create;
	TracedLinks := TObjectList.Create;

	ANetwork.ClearVisits;
	TraceStack.Push(Pointer(RootMarker.LinkID));

	// Initialize trace
	ALink := RootMarker;
	ALink.Visit;
	ALink.DSNode.SetLengthFromRoot(0);
	ALink.DSNode.SetTimeToRoot(0);
	ALink.USNode.SetLengthFromRoot(ALink.Length);
	ALink.USNode.SetTimeToRoot(ALink.TravelTime);
	ALink.CumulativeLength := ALink.Length;
	ALink.CumulativeTime := ALink.TravelTime * VelocityFactor;

	// Trace through network until top or stoplink reached
	while TraceStack.Count > 0 do
	begin
		ALinkID := Integer(TraceStack.Pop);
		ALink := ANetwork.LinkByID(ALinkID);
		UpstreamLinks := ANetwork.FindUpstreamLinks(ALink);
		if Assigned(UpstreamLinks) then
		begin
			for i := 0 to UpstreamLinks.Count - 1 do
			begin
				if not UpstreamLinks[i].HasBeenVisited then
				begin
					if not IsEnd(UpstreamLinks[i]) then
						TraceStack.Push(Pointer(UpstreamLinks[i].LinkID));
					UpstreamLinks[i].Visit;
					UpstreamLinks[i].CumulativeLength := ALink.CumulativeLength +
						UpstreamLinks[i].Length;
					UpstreamLinks[i].CumulativeTime := ALink.CumulativeTime +
						UpstreamLinks[i].TravelTime * VelocityFactor;
					UpstreamLinks[i].USNode.SetLengthFromRoot(UpstreamLinks[i].CumulativeLength);
					UpstreamLinks[i].USNode.SetTimeToRoot(UpstreamLinks[i].CumulativeTime);
					CachedLongestLagTime := Max(UpstreamLinks[i].CumulativeTime,
						CachedLongestLagTime);
				end;
			end;
		end;
		UpstreamLinks.Free;
	end;

	VisitedNodes := ANetwork.VisitedNodes;
	Nodes.AddStrings(VisitedNodes);
	NodesList := TNodesList.Create(True);

	frmProgress.prgProgress.TotalParts := ANetwork.VisitedNodes.Count;
	frmProgress.prgProgress.PartsComplete := 0;
	frmProgress.lblProgress.Caption := 'Copying nodes for distribution';
	frmProgress.Show;

//  CodeSite.AddSeparator;
//  CodeSite.SendFmtMsg('Distribution Rootlink %d', [Self.RootMarker.LinkID]);

	for i := 0 to ANetwork.VisitedNodes.Count - 1 do
	begin
		ANode := ANetwork.NodesList.FindByID(ANetwork.VisitedNodes[i]);
		AddedIndex := NodesList.Add(TNode.Create(ANode));

//    CodeSite.Send('Traced', ANode.NodeID);

		frmProgress.prgProgress.IncPartsByOne;
		Application.ProcessMessages;
	end;
	frmProgress.Hide;

	VisitedNodes.Free;

{
  	CheckStrings := TStringList.Create;
		for i := 0 to NodesList.Count - 1 do
			CheckStrings.Add(NodesList[i].NodeID +' '+ FloatToStr(NodesList[i].TimeToRoot));
		CodeSite.Send('TimeToRoot', CheckStrings);
		CheckStrings.Free;

}
	TracedLinks.Free;
	TraceStack.Free;
end;

procedure TDistribution.UpdateFlows(ATime: TDateTime);
begin
	FlowHistory.MasterTime := ATime;
	if CompareDateTime(IncMinute(ATime, Round(CachedLongestLagTime)), CurrentTime) >= EqualsValue then
		Next;
end;

constructor TDistribution.Create(ANetwork: TNetwork; Root: TLink; Stops: TLinksList;
	FlowFilePath: TFileName; FlowFileSpecs: TFlowFileSpecs; ModelPath: String;
	MainConfigSpecs: TMainConfigSpecs; VelocityFactor: Double);
var
	i: Integer;
	Flow1Line: String;
	Flow2Line: String;
	Flow1: TFlowSeriesDatum;
	ADate: TDateTime;
	Flow2: TFlowSeriesDatum;
	DateFormatStr: String;
	TimeFormatStr: String;
begin
	RootMarker := Root;
	StopMarkers := Stops;
	
	Nodes := TStringList.Create;
	Nodes.Sorted := True;
	Nodes.Duplicates := dupError;

	TimeSeriesPath := FlowFilePath;

	Trace(ANetwork, VelocityFactor);
  try
    AssignNodeProportions(ModelPath, MainConfigSpecs);
  except on E: Exception do
    raise;
  end;

	TimeSeriesStream := TFileStream.Create(TimeSeriesPath, fmOpenRead or fmShareDenyWrite);
	TimeSeriesTextStream := TStAnsiTextStream.Create(TimeSeriesStream);
	Self.FlowFileSpecs := FlowFileSpecs;
	for i := 1 to FlowFileSpecs.HeaderLines do
		TimeSeriesTextStream.ReadLine;

	// Estimate the initial time step
	Flow1Line := TimeSeriesTextStream.ReadLine;
	Flow2Line := TimeSeriesTextStream.ReadLine;

	// Set formatting for dates and times
	GetLocaleFormatSettings(LOCALE_USER_DEFAULT, DistributionFormatSettings);
	DistributionFormatSettings.ShortDateFormat := FlowFileSpecs.DateFormat;
	DateFormatStr := FlowFileSpecs.DateFormat;
	DateFormatStr := KeepCharsL(DateFormatStr, ':-/., ');
	DistributionFormatSettings.DateSeparator := DateFormatStr[1];
	DistributionFormatSettings.ShortTimeFormat := FlowFileSpecs.TimeFormat;
	TimeFormatStr := FlowFileSpecs.TimeFormat;
	TimeFormatStr := KeepCharsL(TimeFormatStr, ':-/., ');
	DistributionFormatSettings.TimeSeparator := TimeFormatStr[1];
	DistributionFormatSettings.TwoDigitYearCenturyWindow := 50;

	Flow1 := ReadFlowLine(Flow1Line);
	Flow2 := ReadFlowLine(Flow2Line);

	EarliestTime := IncMinute(Flow1.Time, -Round(CachedLongestLagTime));
	FlowHistory := TFlowSeriesList.Create(Flow1.Time, Round(CachedLongestLagTime));
	EstimatedTimeStep := SecondSpan(Flow2.Time, Flow1.Time);

	Flow1.Free;
	Flow2.Free;

end;

destructor TDistribution.Destroy;
begin
	FlowHistory.Free;
	TimeSeriesTextStream.Free;
	TimeSeriesStream.Free;
	Nodes.Free;
	StopMarkers.Free;
	inherited;
end;
end.